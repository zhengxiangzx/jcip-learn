## volatile的应用
volatile是轻量级的synchronized，它在多处理器开发中保证了共享变量的“可见性”。

**可见性**是指到一个线程去修改一个共享变量时，其他线程能读到这个修改的值。

如果**volatile**的使用得当，他比synchronized的使用成本更低，因为它不会引起上下文的切换和调度。

volatile修饰的共享变量 在执行时添加了一个Lock前缀的指令。
Lock前缀指令在多核处理器会引发两个操作：
1. 将当前处理器缓存行的数据写回到系统内存中。
2. 这个写回的操作会使其他的CPU里缓存了该内存地址的数据失效。

### volatile 的优化
Doug lea 增加了一个LinkedTransferQueue在使用volatile的时候用了一种追加字节的方式来优化入队和出队的性能。

新的处理器L1 L2 L3高速缓存行都是64字节宽的，不支持部分填充缓存。如何队列的头和队尾不满64位处理器就会将他们读到同一个缓存行中，多处理器的情况下每个缓存都会缓存同样的头尾节点，如果试图修改头节点时就要锁定缓存行，因为内存一致性原理，其他处理器也不能修改尾节点。多处理器的情况下就严重影响了队列的入队和出队效率。
doug lea 采用追加64字节的操作，可以是头字节和尾字节不在同一个缓存行中，使得修改头节点和尾节点互不影响。

以下两个场景不适合：
1. 缓存行非64字节的
2. 共享变量不会被频繁写的。

## synchronized的实现原理与应用
三种表现形式：
1. 对于普通同步方法，锁是当前的实例对象
2. 对于静态同步方法，锁是当前类的class对象
3. 对于同步方法块，锁是Synchronized括号里配置的对象

synchronized的在jvm中实现的原理，jvm进入和退出Monitor对象来实现方法的同步和代码块的同步，两者的实现细节不一样。
代码块同步是使用的monitorenter和monitorexit指令来实现的，而方法同步是另一种指令实现，jvm规范没有详细说明。方法的同步同样可以用这两个指令来实现。
monitorenter是在编译后插入到同步代码块开始的位置，而monitorexit是插入在方法结束和异常处。jvm保证每个monitorenter都有对应的monitorexit与之匹配。

三种锁：
1. 偏向锁：当一个线程访问同步块时
2. 轻量级锁
3. 重量级锁

未完待续