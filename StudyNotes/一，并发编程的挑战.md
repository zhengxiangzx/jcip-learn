## 上下文切换
1. 即使是单核处理器也支持多线程代码，cpu通过给每个线程分配CPU时间片来实现这个机制。时间片是CPU分配给各个线程的时间，因为时间片很短，所有CPU通过不停的切换线程来执行，让我感觉是在多个线程同时执行，时间片一般都是几十毫秒（ms）。
2. CPU通过时间片分配算法来循环执行任务，当前任务在执行完一个时间片后，会切换到下一个任务。但是切换前会保存上一个任务的运行状态，以便下次切换回来这个任务时，可以再加载这个状态。==所以任务从保存到再次加载是一个上下文切换。==
## 多线程一定快吗
分场景，不一定快，线程有创建和上下文的切换调度开销。
### 如何减少上下文的切换
有四点：
1. 无锁并发编程。多线程竞争锁时，会引起上下文的切换，所以多线程处理数据时，可以用一些办法来避免使用锁，如将数据的ID按照Hash算法取模分段，不同的线程处理不同的数据。
2. CAS算法。java的Atomic包使用的CAS算法来更新数据，而不需要加锁。
3. 使用最少的线程。避免创建不需要的线程，比如任务很少，但是创建了很多线程来处理，这样会造成大量的线程都处于等待状态。
4. 使用协程。在单线程里实现多任务的调度，并在单线程里维持多个任务间的切换。
## 死锁
1. 一个线程占用一个锁时，去占用另一个线程占用的锁，而去占用的线程也在去占用当前线程锁，引起了死锁。相互不释放，相互抢占。
2. 一个线程占用锁之后，没有释放锁（因为一些异常没有释放）导致死锁。
3. 一个线程占用了数据库锁，释放锁的时候抛异常，没有释放锁，导致死锁。
### 如何避免死锁
有如下常见方法：
1. 避免一个线程同时占用多个锁。
2. 避免一个线程在锁内同时占用多个资源，尽量保证每个锁只占用一个资源。
3. 尝试使用定时锁，使用lock.tryLock(timeout) 来代替使用内部锁机制。
4. 对于数据库锁，加锁和解锁必须在同一个数据库连接里，否则会出现解锁失败的情况。
## 资源限制挑战
1. 什么是资源限制：资源限制是指在进行并发编程时，程序的执行速度受限于计算硬件资源或者软件资源。例如 服务器的带宽是2Mb/s,某个资源下载的速度是1Mb/s，系统启动了10个线程下载资源，下载速度不会变成10Mb/s，所以在并发编程时要考虑资源的问题，硬件资源的限制有 带宽的上传/下载速度，磁盘的读写速度和cpu的处理速度。软件有数据库的连接和socket连接数。
2. 资源限制引发的问题：在并发编程中，将代码的执行速度加快的原则是将代码中串行执行的地方修改成并行执行。但是如果将串行的代码修改成并行的，因为受资源的限制，仍然在串行，这时候程序不仅没有加快，反而会变慢，因为增加了上下文的切换和资源的调度时间。
3. 如何解决资源限制问题：
   - 对于硬件资源的限制，可以考虑使用集群并行的执行程序。既然单机的资源有限，就让程序执行在多台服务器上。（Hadoop，ODPS）不同的机器处理不同的数据，比如 "数据ID%机器数" 计算一个机器编号，然后由对应编号的机器处理这些数据。
   - 对于软件资源的限制，可以考虑使用资源池来复用。比如使用连接池将数据库和socket连接复用。或者在调用对方的webservice接口获取数据时，只建立一个连接。
4. 在资源限制的情况下进行并发编程：根据不同的资源限制调整程序的并发度。
